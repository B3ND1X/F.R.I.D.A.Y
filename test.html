<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>F.R.I.D.AY Functional Responsive Intelligent Assistant for You</title>
    <style>
        /* CSS styles unchanged */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f9;
            display: flex;
            justify-content: space-between;
            padding: 20px;
            position: relative;
        }
        #chat-box-container {
            width: 40%;
            margin-right: 20px;
            position: relative;
            z-index: 2;
        }
        #chat-box {
            max-width: 600px;
            margin: 0 auto;
            padding: 10px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            height: 400px;
            overflow-y: scroll;
        }
        .message {
            padding: 8px;
            border-radius: 5px;
            margin: 5px 0;
        }
        .user-message {
            background-color: #d1f7ff;
            text-align: right;
        }
        .groq-response {
            background-color: #e8f8e8;
            text-align: left;
        }
        .listening {
            background-color: #fff3cd;
            text-align: center;
            font-weight: bold;
        }
        #user-input {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 80%;
        }
        #send-btn {
            padding: 10px;
            border: none;
            background-color: #007bff;
            color: white;
            border-radius: 4px;
            cursor: pointer;
        }
        #send-btn:hover {
            background-color: #0056b3;
        }
        #news-weather-container {
            width: 35%;
            display: flex;
            flex-direction: column;
            z-index: 2;
        }
        .card {
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: white;
        }
        #weather-info, #news-info {
            font-size: 16px;
            color: #555;
        }

        #orb {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.8) 0%, rgba(0, 128, 255, 0.8) 60%, rgba(0, 64, 128, 0.8) 100%);
            box-shadow: 0 0 10px rgba(0, 128, 255, 0.8), 0 0 40px rgba(0, 128, 255, 0.6);
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease-out;
            z-index: -1;
        }
    </style>
</head>
<body>
    <div id="chat-box-container">
        <div id="chat-box"></div>
        <input type="text" id="user-input" placeholder="Type your message..." />
        <button id="send-btn">Send</button>
    </div>

    <div id="news-weather-container">
        <div class="card">
            <h2>Local Weather</h2>
            <div id="weather-info">Loading weather...</div>
        </div>

        <div class="card">
            <h2>Latest News</h2>
            <div id="news-info">Loading news...</div>
        </div>
    </div>

    <div id="orb"></div> <!-- Orb in the background -->

    <script>
        const apiKey = "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"; // Groq API key
        const weatherApiKey = '80445369031848dbad520436251201'; // Weather API key
        const guardianApiKey = '962cca3b-893a-4285-969b-51e44bf81615'; // The Guardian API key
        const wakeWord = "hey friday";

        let recognition;
        let isListeningForCommand = false;
        let commandBuffer = '';
        let microphonePermissionGranted = false;
        let lastGroqResponse = '';
        const chatBox = document.getElementById('chat-box');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-btn');
        const orb = document.getElementById('orb');
        let inactivityTimeout;
        const INACTIVITY_TIMEOUT = 30000; // 30 seconds inactivity timeout
        let recognizing = false; // Flag to track recognition state

        // Web Audio API setup for capturing sound
        let audioContext, analyser, microphoneStream;
        let bufferLength;
        let dataArray;

        // Function to request microphone access (Only once)
        function requestMicrophoneAccess() {
            return new Promise((resolve, reject) => {
                if (microphonePermissionGranted) {
                    resolve(true); // Already granted
                    return;
                }

                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then((stream) => {
                        microphonePermissionGranted = true;
                        setUpAudioAnalysis(stream);
                        resolve(true);
                    })
                    .catch((err) => {
                        reject("Microphone access denied: " + err);
                    });
            });
        }

        // Set up the Web Audio API analyser
        function setUpAudioAnalysis(stream) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;  // Size of FFT for analyzing frequency data
            bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);

            microphoneStream = audioContext.createMediaStreamSource(stream);
            microphoneStream.connect(analyser);

            // Start analyzing audio every 50ms
            setInterval(updateOrbSize, 50);
        }

        // Update the orb size based on microphone noise
        function updateOrbSize() {
            analyser.getByteFrequencyData(dataArray);

            // Calculate average volume
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i];
            }
            let averageVolume = sum / bufferLength;

            // Map average volume to orb size
            let orbSize = Math.min(100 + averageVolume / 2, 300); // Max size 300px
            orb.style.width = orbSize + 'px';
            orb.style.height = orbSize + 'px';
        }

         // Initialize speech recognition
        function initializeSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window)) {
                alert("Speech recognition is not supported by this browser.");
                return;
            }

            recognition = new webkitSpeechRecognition();
            recognition.continuous = true;  // Continuous listening
            recognition.interimResults = false; // Do not return partial results
            recognition.lang = "en-US";
            recognition.maxAlternatives = 1;

            recognition.onstart = () => {
                console.log("Speech recognition started.");
                recognizing = true; // Set recognizing flag
            };

            recognition.onresult = (event) => {
                let transcript = '';
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    transcript += event.results[i][0].transcript;
                }
                transcript = transcript.trim().toLowerCase();
                console.log("Transcript:", transcript);

                // Detect wake word and command
                if (transcript.includes(wakeWord) && !isListeningForCommand) {
                    console.log("Wake word detected!");
                    playWakeWordSound(); // Play activation sound
                    isListeningForCommand = true;
                    displayMessage("Listening for your command...", 'groq-response');
                    commandBuffer = '';
                    return; // Do not process yet, continue listening
                }

                if (isListeningForCommand && transcript && transcript !== wakeWord) {
                    if (transcript.length < 3) {
                        return; // Avoid sending incomplete or very short prompts
                    }

                    commandBuffer = transcript;
                    console.log("Captured command:", commandBuffer);

                    // Set a timer for X amount of minutes or seconds
                    if (commandBuffer.startsWith("set a timer for")) {
                        // Your timer logic here
                        // Timer variables
let activeTimer = null; // Stores the current timer's ID
let timerEndTime = null; // Stores when the timer will end

recognition.onresult = (event) => {
    let transcript = '';
    for (let i = event.resultIndex; i < event.results.length; i++) {
        transcript += event.results[i][0].transcript;
    }
    transcript = transcript.trim().toLowerCase();
    console.log("Transcript:", transcript);

    if (transcript.includes(wakeWord) && !isListeningForCommand) {
        console.log("Wake word detected!");
        playWakeWordSound(); // Play activation sound
        isListeningForCommand = true;
        displayMessage("Listening for your command...", 'groq-response');
        commandBuffer = '';
        return;
    }

    if (isListeningForCommand && transcript && transcript !== wakeWord) {
        if (transcript.length < 3) {
            return; // Avoid processing very short commands
        }

        commandBuffer = transcript;
        console.log("Captured command:", commandBuffer);

        // Handle "set a timer" command
        if (commandBuffer.startsWith("set a timer for")) {
            const timeMatch = commandBuffer.match(/(\d+)\s*(seconds?|minutes?)/);
            if (timeMatch) {
                const amount = parseInt(timeMatch[1], 10);
                const unit = timeMatch[2];
                const duration = unit.startsWith("minute") ? amount * 60 * 1000 : amount * 1000;

                // Cancel any existing timer
                if (activeTimer) {
                    clearTimeout(activeTimer);
                    activeTimer = null;
                    displayMessage("Previous timer canceled.", 'groq-response');
                    speakText("Previous timer canceled.");
                }

                // Set new timer
                activeTimer = setTimeout(() => {
                    const timerEndMessage = `Timer is up! ${amount} ${unit} have passed.`;
                    displayMessage(timerEndMessage, 'groq-response');
                    speakText(timerEndMessage);
                    activeTimer = null; // Clear active timer after completion
                }, duration);

                // Store end time for potential future reference
                timerEndTime = Date.now() + duration;

                const message = `Timer is set for ${amount} ${unit}.`;
                displayMessage(message, 'groq-response');
                speakText(message);
            } else {
                displayMessage("I couldn't understand the timer duration.", 'groq-response');
                speakText("I couldn't understand the timer duration.");
            }
        }

        // Handle "cancel the timer" command
        else if (commandBuffer.includes("cancel the timer")) {
            if (activeTimer) {
                clearTimeout(activeTimer);
                activeTimer = null;
                displayMessage("Timer has been canceled.", 'groq-response');
                speakText("Timer has been canceled.");
            } else {
                displayMessage("No active timer to cancel.", 'groq-response');
                speakText("No active timer to cancel.");
            }
        }

        // Handle other commands
        else if (commandBuffer.includes('what time is it')) {
            const currentTime = new Date().toLocaleTimeString();
            const message = `The current time is ${currentTime}.`;
            displayMessage(message, 'groq-response');
            speakText(message);
        } else {
            displayMessage("Processing your request...", 'groq-response');
            sendToGroq(commandBuffer); // Send other commands to Groq
        }

        commandBuffer = ''; // Reset buffer after processing
        isListeningForCommand = false; // End listening for command
    }

    resetInactivityTimer(); // Reset inactivity timer after receiving speech
};
                    }

                    // Set an alarm for X time
                    else if (commandBuffer.startsWith("set an alarm for")) {
                        // Alarm variables
let activeAlarm = null; // Stores the ID of the alarm's timeout
let alarmTime = null; // Stores the alarm time

recognition.onresult = (event) => {
    let transcript = '';
    for (let i = event.resultIndex; i < event.results.length; i++) {
        transcript += event.results[i][0].transcript;
    }
    transcript = transcript.trim().toLowerCase();
    console.log("Transcript:", transcript);

    if (transcript.includes(wakeWord) && !isListeningForCommand) {
        console.log("Wake word detected!");
        playWakeWordSound(); // Play activation sound
        isListeningForCommand = true;
        displayMessage("Listening for your command...", 'groq-response');
        commandBuffer = '';
        return;
    }

    if (isListeningForCommand && transcript && transcript !== wakeWord) {
        if (transcript.length < 3) {
            return; // Avoid processing very short commands
        }

        commandBuffer = transcript;
        console.log("Captured command:", commandBuffer);

        // Handle "set an alarm" command
        if (commandBuffer.startsWith("set an alarm for")) {
            const timeMatch = commandBuffer.match(/(\d{1,2}):(\d{2})\s*(am|pm)/);
            if (timeMatch) {
                const hours = parseInt(timeMatch[1], 10);
                const minutes = parseInt(timeMatch[2], 10);
                const period = timeMatch[3];

                // Convert 12-hour time to 24-hour time
                let alarmHours = period === "pm" && hours !== 12 ? hours + 12 : hours;
                alarmHours = period === "am" && hours === 12 ? 0 : alarmHours;

                // Get current date and set alarm time
                const now = new Date();
                alarmTime = new Date();
                alarmTime.setHours(alarmHours, minutes, 0, 0);

                // Check if the alarm time is in the past and adjust to the next day
                if (alarmTime <= now) {
                    alarmTime.setDate(alarmTime.getDate() + 1);
                }

                const timeUntilAlarm = alarmTime - now;

                // Cancel any existing alarm
                if (activeAlarm) {
                    clearTimeout(activeAlarm);
                    activeAlarm = null;
                    displayMessage("Previous alarm canceled.", 'groq-response');
                    speakText("Previous alarm canceled.");
                }

                // Set the alarm
                activeAlarm = setTimeout(() => {
                    const alarmMessage = "Alarm is going off! It's time!";
                    displayMessage(alarmMessage, 'groq-response');
                    speakText(alarmMessage);
                    activeAlarm = null; // Clear active alarm after it goes off
                }, timeUntilAlarm);

                const alarmSetMessage = `Alarm is set for ${alarmTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}.`;
                displayMessage(alarmSetMessage, 'groq-response');
                speakText(alarmSetMessage);
            } else {
                displayMessage("I couldn't understand the alarm time format. Please use a format like '7:30 AM'.", 'groq-response');
                speakText("I couldn't understand the alarm time format. Please use a format like '7:30 AM'.");
            }
        }

        // Handle "cancel the alarm" command
        else if (commandBuffer.includes("cancel the alarm")) {
            if (activeAlarm) {
                clearTimeout(activeAlarm);
                activeAlarm = null;
                alarmTime = null;
                displayMessage("Alarm has been canceled.", 'groq-response');
                speakText("Alarm has been canceled.");
            } else {
                displayMessage("No active alarm to cancel.", 'groq-response');
                speakText("No active alarm to cancel.");
            }
        }

        // Handle other commands
        else if (commandBuffer.includes('what time is it')) {
            const currentTime = new Date().toLocaleTimeString();
            const message = `The current time is ${currentTime}.`;
            displayMessage(message, 'groq-response');
            speakText(message);
        } else {
            displayMessage("Processing your request...", 'groq-response');
            sendToGroq(commandBuffer); // Send other commands to Groq
        }

        commandBuffer = ''; // Reset buffer after processing
        isListeningForCommand = false; // End listening for command
    }

    resetInactivityTimer(); // Reset inactivity timer after receiving speech
};
                    }

                    // What is the weather
                    else if (commandBuffer.includes("what is the weather")) {
                        fetchWeather(); // Your weather fetch function
                        // Weather variables
const weatherApiKey = 'YOUR_WEATHER_API_KEY'; // Replace with your actual API key
const weatherApiUrl = 'https://api.openweathermap.org/data/2.5/weather'; // Adjust if needed

async function getWeatherForecast() {
    try {
        // Fetch the user's current location (assuming latitude and longitude are available)
        const locationResponse = await fetch('https://ipapi.co/json/'); // Replace with your location API
        const locationData = await locationResponse.json();

        const { latitude, longitude, city } = locationData;

        // Fetch weather data from the API
        const weatherResponse = await fetch(
            `${weatherApiUrl}?lat=${latitude}&lon=${longitude}&units=metric&appid=${weatherApiKey}`
        );
        const weatherData = await weatherResponse.json();

        if (weatherData.cod === 200) {
            const { main, weather, wind } = weatherData;
            const temperature = Math.round(main.temp);
            const condition = weather[0].description;
            const windSpeed = Math.round(wind.speed);

            const forecastMessage = `The current weather in ${city} is ${condition} with a temperature of ${temperature}°C and wind speed of ${windSpeed} km/h.`;
            displayMessage(forecastMessage, 'groq-response');
            speakText(forecastMessage);
        } else {
            displayMessage("I couldn't fetch the weather information. Please try again later.", 'groq-response');
            speakText("I couldn't fetch the weather information. Please try again later.");
        }
    } catch (error) {
        console.error("Error fetching weather data:", error);
        displayMessage("There was an error retrieving the weather. Please try again later.", 'groq-response');
        speakText("There was an error retrieving the weather. Please try again later.");
    }
}

recognition.onresult = (event) => {
    let transcript = '';
    for (let i = event.resultIndex; i < event.results.length; i++) {
        transcript += event.results[i][0].transcript;
    }
    transcript = transcript.trim().toLowerCase();
    console.log("Transcript:", transcript);

    if (transcript.includes(wakeWord) && !isListeningForCommand) {
        console.log("Wake word detected!");
        playWakeWordSound();
        isListeningForCommand = true;
        displayMessage("Listening for your command...", 'groq-response');
        commandBuffer = '';
        return;
    }

    if (isListeningForCommand && transcript && transcript !== wakeWord) {
        if (transcript.length < 3) {
            return;
        }

        commandBuffer = transcript;
        console.log("Captured command:", commandBuffer);

        // Handle "what is the weather" command
        if (commandBuffer.includes("what is the weather")) {
            displayMessage("Fetching the weather forecast...", 'groq-response');
            speakText("Fetching the weather forecast...");
            getWeatherForecast();
        }

        // Handle other commands as usual
        else if (commandBuffer.includes('cancel the alarm')) {
            if (activeAlarm) {
                clearTimeout(activeAlarm);
                activeAlarm = null;
                alarmTime = null;
                displayMessage("Alarm has been canceled.", 'groq-response');
                speakText("Alarm has been canceled.");
            } else {
                displayMessage("No active alarm to cancel.", 'groq-response');
                speakText("No active alarm to cancel.");
            }
        } else {
            displayMessage("Processing your request...", 'groq-response');
            sendToGroq(commandBuffer);
        }

        commandBuffer = ''; // Reset buffer after processing
        isListeningForCommand = false; // End listening for command
    }

    resetInactivityTimer();
};
                    }

                    // What is the news
                    else if (commandBuffer.includes("what is the news")) {
                        fetchNews(); // Your news fetch function
                        // Function to fetch and read top 3 news headlines
async function getNewsHeadlines() {
    try {
        // Fetch top news articles from The Guardian API
        const guardianUrl = `https://content.guardianapis.com/search?api-key=${guardianApiKey}`;
        const newsResponse = await fetch(guardianUrl);
        const newsData = await newsResponse.json();

        if (newsData.response && newsData.response.results) {
            const articles = newsData.response.results.slice(0, 3); // Get top 3 articles
            let newsMessage = "Here are the top 3 headlines:";
            articles.forEach((article, index) => {
                newsMessage += ` Headline ${index + 1}: ${article.webTitle}.`;
            });

            displayMessage(newsMessage, 'groq-response'); // Display in chat box
            speakText(newsMessage); // Speak the headlines
        } else {
            const errorMessage = "I couldn't fetch the news. Please try again later.";
            displayMessage(errorMessage, 'groq-response');
            speakText(errorMessage);
        }
    } catch (error) {
        console.error("Error fetching news data:", error);
        const errorMessage = "There was an error retrieving the news. Please try again later.";
        displayMessage(errorMessage, 'groq-response');
        speakText(errorMessage);
    }
}

// Add "news" command handling in speech recognition logic
recognition.onresult = (event) => {
    let transcript = '';
    for (let i = event.resultIndex; i < event.results.length; i++) {
        transcript += event.results[i][0].transcript;
    }
    transcript = transcript.trim().toLowerCase();
    console.log("Transcript:", transcript);

    if (transcript.includes(wakeWord) && !isListeningForCommand) {
        console.log("Wake word detected!");
        playWakeWordSound();
        isListeningForCommand = true;
        displayMessage("Listening for your command...", 'groq-response');
        commandBuffer = '';
        return;
    }

    if (isListeningForCommand && transcript && transcript !== wakeWord) {
        if (transcript.length < 3) {
            return;
        }

        commandBuffer = transcript;
        console.log("Captured command:", commandBuffer);

        // Handle "what is the news" command
        if (commandBuffer.includes("what is the news")) {
            displayMessage("Fetching the top news headlines...", 'groq-response');
            speakText("Fetching the top news headlines...");
            getNewsHeadlines();
        }

        // Handle other commands as usual
        else if (commandBuffer.includes('cancel the alarm')) {
            if (activeAlarm) {
                clearTimeout(activeAlarm);
                activeAlarm = null;
                alarmTime = null;
                displayMessage("Alarm has been canceled.", 'groq-response');
                speakText("Alarm has been canceled.");
            } else {
                displayMessage("No active alarm to cancel.", 'groq-response');
                speakText("No active alarm to cancel.");
            }
        } else {
            displayMessage("Processing your request...", 'groq-response');
            sendToGroq(commandBuffer);
        }

        commandBuffer = ''; // Reset buffer after processing
        isListeningForCommand = false; // End listening for command
    }

    resetInactivityTimer();
};
                    }

                    // What is the score or who is winning
                    else if (commandBuffer.includes("what is the score") || commandBuffer.includes("who is winning")) {
                        // Your sports score fetch logic here
                        const sportsApiKey = 'YOUR_SPORTS_API_KEY'; // Replace with your Sports API key

// Function to fetch live sports scores
async function getSportsScores() {
    try {
        // Example API endpoint for live scores
        const sportsUrl = `https://api.sportsapi.com/v1/scores/live?api_key=${sportsApiKey}`;
        const sportsResponse = await fetch(sportsUrl);
        const sportsData = await sportsResponse.json();

        if (sportsData && sportsData.length > 0) {
            let scoresMessage = "Here are the current sports scores:";
            sportsData.forEach((game, index) => {
                const { homeTeam, awayTeam, homeScore, awayScore, status } = game;
                scoresMessage += ` Game ${index + 1}: ${homeTeam} ${homeScore} - ${awayTeam} ${awayScore}. Status: ${status}.`;
            });

            displayMessage(scoresMessage, 'groq-response'); // Display in chat box
            speakText(scoresMessage); // Speak the scores
        } else {
            const noScoresMessage = "I couldn't find any live games at the moment.";
            displayMessage(noScoresMessage, 'groq-response');
            speakText(noScoresMessage);
        }
    } catch (error) {
        console.error("Error fetching sports scores:", error);
        const errorMessage = "There was an error retrieving the sports scores. Please try again later.";
        displayMessage(errorMessage, 'groq-response');
        speakText(errorMessage);
    }
}

// Add "sports scores" command handling in speech recognition logic
recognition.onresult = (event) => {
    let transcript = '';
    for (let i = event.resultIndex; i < event.results.length; i++) {
        transcript += event.results[i][0].transcript;
    }
    transcript = transcript.trim().toLowerCase();
    console.log("Transcript:", transcript);

    if (transcript.includes(wakeWord) && !isListeningForCommand) {
        console.log("Wake word detected!");
        playWakeWordSound();
        isListeningForCommand = true;
        displayMessage("Listening for your command...", 'groq-response');
        commandBuffer = '';
        return;
    }

    if (isListeningForCommand && transcript && transcript !== wakeWord) {
        if (transcript.length < 3) {
            return;
        }

        commandBuffer = transcript;
        console.log("Captured command:", commandBuffer);

        // Handle "what is the score" or "who is winning" command
        if (
            commandBuffer.includes("what is the score") ||
            commandBuffer.includes("who is winning") ||
            commandBuffer.includes("sports scores")
        ) {
            displayMessage("Fetching the latest sports scores...", 'groq-response');
            speakText("Fetching the latest sports scores...");
            getSportsScores();
        }

        // Handle other commands as usual
        else {
            displayMessage("Processing your request...", 'groq-response');
            sendToGroq(commandBuffer);
        }

        commandBuffer = ''; // Reset buffer after processing
        isListeningForCommand = false; // End listening for command
    }

    resetInactivityTimer();
};
                    }

                    // Search for (searches the web)
                    else if (commandBuffer.startsWith("search for")) {
                        const searchTerm = commandBuffer.slice(11); // Extract search term
                        // Your web search logic here
                         // Search the web
    function searchWeb(query) {
        const searchQuery = query.replace("search for", "").trim();
        if (searchQuery) {
            window.open(`https://www.google.com/search?q=${searchQuery}`);
            speakText(`Searching for ${searchQuery}`);
        } else {
            speakText("Please specify what you'd like to search for.");
        }
    }
                    }

                    // New movies or what movies are playing
                    else if (commandBuffer.includes("what are some new movies") || commandBuffer.includes("what movies are playing")) {
                        // Your movie fetch logic here
                        const movieApiKey = 'YOUR_TMDB_API_KEY'; // Replace with your TMDb API key

// Function to fetch new movie releases
async function getNewMovies() {
    try {
        // Example TMDb endpoint for now playing movies
        const movieUrl = `https://api.themoviedb.org/3/movie/now_playing?api_key=${movieApiKey}&language=en-US&page=1`;
        const movieResponse = await fetch(movieUrl);
        const movieData = await movieResponse.json();

        if (movieData.results && movieData.results.length > 0) {
            let movieMessage = "Here are some new movies now playing:";
            movieData.results.slice(0, 5).forEach((movie, index) => {
                const title = movie.title;
                const releaseDate = movie.release_date;
                movieMessage += ` Movie ${index + 1}: "${title}" released on ${releaseDate}.`;
            });

            displayMessage(movieMessage, 'groq-response'); // Display in chat box
            speakText(movieMessage); // Speak the movie list
        } else {
            const noMoviesMessage = "I couldn't find any new movies at the moment.";
            displayMessage(noMoviesMessage, 'groq-response');
            speakText(noMoviesMessage);
        }
    } catch (error) {
        console.error("Error fetching new movies:", error);
        const errorMessage = "There was an error retrieving the movie list. Please try again later.";
        displayMessage(errorMessage, 'groq-response');
        speakText(errorMessage);
    }
}

// Add "new movies" command handling in speech recognition logic
recognition.onresult = (event) => {
    let transcript = '';
    for (let i = event.resultIndex; i < event.results.length; i++) {
        transcript += event.results[i][0].transcript;
    }
    transcript = transcript.trim().toLowerCase();
    console.log("Transcript:", transcript);

    if (transcript.includes(wakeWord) && !isListeningForCommand) {
        console.log("Wake word detected!");
        playWakeWordSound();
        isListeningForCommand = true;
        displayMessage("Listening for your command...", 'groq-response');
        commandBuffer = '';
        return;
    }

    if (isListeningForCommand && transcript && transcript !== wakeWord) {
        if (transcript.length < 3) {
            return;
        }

        commandBuffer = transcript;
        console.log("Captured command:", commandBuffer);

        // Handle "new movies" command
        if (
            commandBuffer.includes("new movies") ||
            commandBuffer.includes("what are some new movies") ||
            commandBuffer.includes("what's playing")
        ) {
            displayMessage("Fetching the latest new movies...", 'groq-response');
            speakText("Fetching the latest new movies...");
            getNewMovies();
        }

        // Handle other commands as usual
        else {
            displayMessage("Processing your request...", 'groq-response');
            sendToGroq(commandBuffer);
        }

        commandBuffer = ''; // Reset buffer after processing
        isListeningForCommand = false; // End listening for command
    }

    resetInactivityTimer();
};
                    }

                    // New music
                    else if (commandBuffer.includes("what is some new music")) {
                        // Your new music fetch logic here
                        const spotifyAccessToken = 'YOUR_SPOTIFY_ACCESS_TOKEN'; // Replace with your Spotify access token

// Function to fetch new music releases
async function getNewMusicReleases() {
    try {
        const musicUrl = `https://api.spotify.com/v1/browse/new-releases?limit=5`;
        const response = await fetch(musicUrl, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${spotifyAccessToken}`,
                'Content-Type': 'application/json'
            }
        });

        const data = await response.json();

        if (data.albums && data.albums.items.length > 0) {
            let musicMessage = "Here are some new music releases:";
            data.albums.items.forEach((album, index) => {
                const albumName = album.name;
                const artistName = album.artists.map(artist => artist.name).join(", ");
                const releaseDate = album.release_date;
                musicMessage += ` Album ${index + 1}: "${albumName}" by ${artistName}, released on ${releaseDate}.`;
            });

            displayMessage(musicMessage, 'groq-response'); // Display in chat box
            speakText(musicMessage); // Speak the music list
        } else {
            const noMusicMessage = "I couldn't find any new music releases at the moment.";
            displayMessage(noMusicMessage, 'groq-response');
            speakText(noMusicMessage);
        }
    } catch (error) {
        console.error("Error fetching new music releases:", error);
        const errorMessage = "There was an error retrieving the music list. Please try again later.";
        displayMessage(errorMessage, 'groq-response');
        speakText(errorMessage);
    }
}

// Add "new music" command handling in speech recognition logic
recognition.onresult = (event) => {
    let transcript = '';
    for (let i = event.resultIndex; i < event.results.length; i++) {
        transcript += event.results[i][0].transcript;
    }
    transcript = transcript.trim().toLowerCase();
    console.log("Transcript:", transcript);

    if (transcript.includes(wakeWord) && !isListeningForCommand) {
        console.log("Wake word detected!");
        playWakeWordSound();
        isListeningForCommand = true;
        displayMessage("Listening for your command...", 'groq-response');
        commandBuffer = '';
        return;
    }

    if (isListeningForCommand && transcript && transcript !== wakeWord) {
        if (transcript.length < 3) {
            return;
        }

        commandBuffer = transcript;
        console.log("Captured command:", commandBuffer);

        // Handle "new music" command
        if (
            commandBuffer.includes("new music") ||
            commandBuffer.includes("what are some new music") ||
            commandBuffer.includes("what's new in music")
        ) {
            displayMessage("Fetching the latest music releases...", 'groq-response');
            speakText("Fetching the latest music releases...");
            getNewMusicReleases();
        }

        // Handle other commands as usual
        else {
            displayMessage("Processing your request...", 'groq-response');
            sendToGroq(commandBuffer);
        }

        commandBuffer = ''; // Reset buffer after processing
        isListeningForCommand = false; // End listening for command
    }

    resetInactivityTimer();
};
                    }

                  // Spotify API variables
const spotifyToken = 'YOUR_SPOTIFY_ACCESS_TOKEN'; // Replace with your Spotify token
let player;

// Initialize speech recognition
function initializeSpeechRecognition() {
    if (!('webkitSpeechRecognition' in window)) {
        alert("Speech recognition is not supported by this browser.");
        return;
    }

    recognition = new webkitSpeechRecognition();
    recognition.continuous = true;
    recognition.interimResults = false;
    recognition.lang = "en-US";
    recognition.maxAlternatives = 1;

    recognition.onstart = () => {
        console.log("Speech recognition started.");
        recognizing = true;
    };

    recognition.onresult = (event) => {
        let transcript = '';
        for (let i = event.resultIndex; i < event.results.length; i++) {
            transcript += event.results[i][0].transcript;
        }
        transcript = transcript.trim().toLowerCase();
        console.log("Transcript:", transcript);

        // Detect wake word and command
        if (transcript.includes(wakeWord) && !isListeningForCommand) {
            console.log("Wake word detected!");
            isListeningForCommand = true;
            displayMessage("Listening for your command...", 'groq-response');
            commandBuffer = '';
            return; // Continue listening for the next command
        }

        if (isListeningForCommand && transcript && transcript !== wakeWord) {
            if (transcript.length < 3) {
                return; // Avoid processing very short commands
            }

            commandBuffer = transcript;
            console.log("Captured command:", commandBuffer);

            // Spotify-related commands
            if (commandBuffer.includes('play') || commandBuffer.includes('pause') || commandBuffer.includes('next') || commandBuffer.includes('previous')) {
                controlSpotify(commandBuffer);
            } else {
                displayMessage("Sorry, I didn't understand that command.", 'groq-response');
            }

            isListeningForCommand = false;
            commandBuffer = ''; // Reset command buffer
        }
    };

    recognition.onerror = (event) => {
        console.error("Speech recognition error:", event.error);
    };

    recognition.onend = () => {
        console.log("Speech recognition ended.");
        recognizing = false;
        recognition.start(); // Restart recognition when it ends
    };

    recognition.start();
}

// Send command to control Spotify
function controlSpotify(command) {
    if (command.includes('play')) {
        playSpotify();
    } else if (command.includes('pause')) {
        pauseSpotify();
    } else if (command.includes('next')) {
        nextTrackSpotify();
    } else if (command.includes('previous')) {
        previousTrackSpotify();
    }
}

// Play Spotify
function playSpotify() {
    fetch('https://api.spotify.com/v1/me/player/play', {
        method: 'PUT',
        headers: {
            'Authorization': `Bearer ${spotifyToken}`,
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        console.log("Playback started:", data);
        displayMessage("Playing music...", 'groq-response');
    })
    .catch(error => console.error('Error playing Spotify:', error));
}

// Pause Spotify
function pauseSpotify() {
    fetch('https://api.spotify.com/v1/me/player/pause', {
        method: 'PUT',
        headers: {
            'Authorization': `Bearer ${spotifyToken}`,
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        console.log("Playback paused:", data);
        displayMessage("Music paused.", 'groq-response');
    })
    .catch(error => console.error('Error pausing Spotify:', error));
}

// Next track on Spotify
function nextTrackSpotify() {
    fetch('https://api.spotify.com/v1/me/player/next', {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${spotifyToken}`,
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        console.log("Next track:", data);
        displayMessage("Skipping to next track.", 'groq-response');
    })
    .catch(error => console.error('Error skipping to next track:', error));
}

// Previous track on Spotify
function previousTrackSpotify() {
    fetch('https://api.spotify.com/v1/me/player/previous', {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${spotifyToken}`,
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        console.log("Previous track:", data);
        displayMessage("Going to the previous track.", 'groq-response');
    })
    .catch(error => console.error('Error going to previous track:', error));
}

// Display messages in the chat box
function displayMessage(content, className) {
    const messageElement = document.createElement('div');
    messageElement.classList.add('message', className);
    messageElement.textContent = content;
    chatBox.appendChild(messageElement);
    chatBox.scrollTop = chatBox.scrollHeight;
}

// Handle the user's text input
function handleUserInput() {
    const userMessage = userInput.value.trim();
    if (userMessage) {
        displayMessage(userMessage, 'user-message');
        // You can process user input here (e.g., send to server or command handler)
        userInput.value = '';
    }
}
                    // Other commands to send to Groq
                    else {
                        displayMessage("Processing your request...", 'groq-response');
                        sendToGroq(commandBuffer); // Send other commands to Groq
                    }

                    commandBuffer = ''; // Reset buffer after processing
                    isListeningForCommand = false; // End listening for command
                }

                resetInactivityTimer(); // Reset inactivity timer after receiving speech
            };

            recognition.onerror = (event) => {
                console.error("Speech recognition error:", event.error);
                restartSpeechRecognition(); // Restart recognition on error
            };

            recognition.onend = () => {
                console.log("Speech recognition ended.");
                recognizing = false; // Reset recognizing flag
                restartSpeechRecognition(); // Restart recognition when it ends
            };

            if (!recognizing) { // Only start recognition if it's not already running
                recognition.start();
            }
        }

           

        // Function to restart speech recognition
        function restartSpeechRecognition() {
            console.log("Restarting speech recognition...");
            if (recognition) {
                recognition.stop(); // Stop current recognition
                recognition.start(); // Restart recognition
            }
        }

        // Function to play sound when wake word is detected
        function playWakeWordSound() {
            const audio = new Audio('activation.wav');
            audio.play();
        }

        // Send the user's input to Groq
        function sendToGroq(prompt) {
            fetch("https://api.groq.com/openai/v1/chat/completions", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${apiKey}`,
                },
                body: JSON.stringify({
                    model: "llama-3.3-70b-versatile",
                    messages: [{
                        role: "user",
                        content: prompt
                    }]
                })
            })
            .then(response => response.json())
            .then(data => {
                displayMessage(data.choices[0].message.content, 'groq-response');
                console.log("Groq response:", data.choices[0].message.content);
                lastGroqResponse = data.choices[0].message.content;
                speakText(lastGroqResponse);
            })
            .catch(error => {
                console.error("Error:", error);
                displayMessage("Error communicating with Groq.", 'groq-response');
            });
        }

        // Display a message in the chat box
        function displayMessage(content, className) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message', className);
            messageElement.textContent = content;
            chatBox.appendChild(messageElement);
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        // Handle the user's text input
        function handleUserInput() {
            const userMessage = userInput.value.trim();
            if (userMessage) {
                displayMessage(userMessage, 'user-message');
                sendToGroq(userMessage);
                userInput.value = '';
            }
        }

        // Text-to-Speech (TTS) Function
        function speakText(text) {
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(text);
                speechSynthesis.speak(utterance);
            } else {
                console.log("TTS is not supported by this browser.");
            }
        }

               // Weather Fetch with Location
        function fetchWeather() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition((position) => {
                    const latitude = position.coords.latitude;
                    const longitude = position.coords.longitude;
        
                    // Fetch weather using the latitude and longitude
                    const weatherUrl = `https://api.weatherapi.com/v1/current.json?key=${weatherApiKey}&q=${latitude},${longitude}&aqi=no`;
        
                    fetch(weatherUrl)
                        .then(response => response.json())
                        .then(data => {
                            const temperature = data.current.temp_c;
                            const description = data.current.condition.text;
                            const weatherText = `${temperature}°C, ${description}`;
                            document.getElementById('weather-info').textContent = weatherText;
                        })
                        .catch(error => {
                            console.error("Error fetching weather data:", error);
                            document.getElementById('weather-info').textContent = "Failed to load weather.";
                        });
                }, () => {
                    document.getElementById('weather-info').textContent = "Geolocation access denied.";
                });
            } else {
                document.getElementById('weather-info').textContent = "Geolocation not supported by this browser.";
            }
        }

        // News Fetch - The Guardian
        function fetchNews() {
            const guardianUrl = `https://content.guardianapis.com/search?api-key=${guardianApiKey}`;

            fetch(guardianUrl)
                .then(response => response.json())
                .then(data => {
                    if (data.response && data.response.results) {
                        const articles = data.response.results;
                        let newsText = '';
                        articles.forEach((article, index) => {
                            if (index < 3) {
                                newsText += `<strong>${article.webTitle}</strong><br><a href="${article.webUrl}" target="_blank">${article.sectionName}</a><br><br>`;
                            }
                        });
                        document.getElementById('news-info').innerHTML = newsText || "No news available.";
                    } else {
                        console.error("No articles available");
                        document.getElementById('news-info').textContent = "Failed to load news.";
                    }
                })
                .catch(error => {
                    console.error("Error fetching news data:", error);
                    document.getElementById('news-info').textContent = "Failed to load news.";
                });
        }

        // Inactivity reset timer
        function resetInactivityTimer() {
            clearTimeout(inactivityTimeout);
            inactivityTimeout = setTimeout(() => {
                console.log("No activity detected, silently refreshing...");
                silentRefresh();
            }, INACTIVITY_TIMEOUT);
        }

        // Silent refresh function
        function silentRefresh() {
            // Refresh weather and news (fetch again or reset display)
            fetchWeather();   // Fetch weather again to reset the data
            fetchNews();      // Fetch news again to reset the data

            // Reset Text-to-Speech (TTS) functionality if needed
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();  // Stop any ongoing TTS before restarting
            }

            // Restart speech recognition (SST)
            if (!recognizing) { // Ensure we restart only if recognition is not running
                recognition.start();
            }

            // Optionally log or perform any other reset logic
            console.log("Assistant's TTS, SST, weather, and news have been refreshed.");
        }

        // Setup and initialize the assistant when the page loads
        window.onload = function () {
            fetchWeather();
            fetchNews();
            requestMicrophoneAccess().then(() => {
                initializeSpeechRecognition(); // Initialize speech recognition after microphone access is granted
            }).catch((error) => {
                console.error(error);
                alert("Assistant cannot run without microphone access.");
            });

            sendButton.addEventListener('click', handleUserInput);
        };
    </script>
</body>
</html>
